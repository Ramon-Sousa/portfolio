"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/notion-to-md";
exports.ids = ["vendor-chunks/notion-to-md"];
exports.modules = {

/***/ "(rsc)/./node_modules/notion-to-md/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/notion-to-md/build/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./notion-to-md */ \"(rsc)/./node_modules/notion-to-md/build/notion-to-md.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL2luZGV4LmpzPzA1NWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ub3Rpb24tdG8tbWRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/notion-to-md.js":
/*!*********************************************************!*\
  !*** ./node_modules/notion-to-md/build/notion-to-md.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotionToMarkdown = void 0;\nconst md = __importStar(__webpack_require__(/*! ./utils/md */ \"(rsc)/./node_modules/notion-to-md/build/utils/md.js\"));\nconst notion_1 = __webpack_require__(/*! ./utils/notion */ \"(rsc)/./node_modules/notion-to-md/build/utils/notion.js\");\n/**\n * Converts a Notion page to Markdown.\n */\nclass NotionToMarkdown {\n    constructor(options) {\n        this.notionClient = options.notionClient;\n        const defaultConfig = {\n            separateChildPage: false,\n            convertImagesToBase64: false,\n            parseChildPages: true,\n        };\n        this.config = { ...defaultConfig, ...options.config };\n        this.customTransformers = {};\n    }\n    setCustomTransformer(type, transformer) {\n        this.customTransformers[type] = transformer;\n        return this;\n    }\n    /**\n     * Converts Markdown Blocks to string\n     * @param {MdBlock[]} mdBlocks - Array of markdown blocks\n     * @param {number} nestingLevel - Defines max depth of nesting\n     * @returns {MdStringObject} - Returns markdown string with child pages separated\n     */\n    toMarkdownString(mdBlocks = [], pageIdentifier = \"parent\", nestingLevel = 0) {\n        let mdOutput = {};\n        mdBlocks.forEach((mdBlocks) => {\n            // NOTE: toggle in the child blocks logic\n            // adding a toggle check prevents duplicate\n            // rendering of toggle title\n            // process parent blocks\n            if (mdBlocks.parent &&\n                mdBlocks.type !== \"toggle\" &&\n                mdBlocks.type !== \"child_page\") {\n                if (mdBlocks.type !== \"to_do\" &&\n                    mdBlocks.type !== \"bulleted_list_item\" &&\n                    mdBlocks.type !== \"numbered_list_item\") {\n                    // initialize if key doesn't exist\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    // add extra line breaks non list blocks\n                    mdOutput[pageIdentifier] += `\\n${md.addTabSpace(mdBlocks.parent, nestingLevel)}\\n\\n`;\n                }\n                else {\n                    // initialize if key doesn't exist\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    mdOutput[pageIdentifier] += `${md.addTabSpace(mdBlocks.parent, nestingLevel)}\\n`;\n                }\n            }\n            // process child blocks\n            if (mdBlocks.children && mdBlocks.children.length > 0) {\n                if (mdBlocks.type === \"synced_block\" ||\n                    mdBlocks.type === \"column_list\" ||\n                    mdBlocks.type === \"column\") {\n                    let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    Object.keys(mdstr).forEach((key) => {\n                        if (mdOutput[key]) {\n                            mdOutput[key] += mdstr[key];\n                        }\n                        else {\n                            mdOutput[key] = mdstr[key];\n                        }\n                    });\n                }\n                else if (mdBlocks.type === \"child_page\") {\n                    const childPageTitle = mdBlocks.parent;\n                    let mdstr = this.toMarkdownString(mdBlocks.children, childPageTitle);\n                    if (this.config.separateChildPage) {\n                        mdOutput = { ...mdOutput, ...mdstr };\n                    }\n                    else {\n                        mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                        if (mdstr[childPageTitle]) {\n                            // child page heading followed by child page content\n                            mdOutput[pageIdentifier] += `\\n${childPageTitle}\\n${mdstr[childPageTitle]}`;\n                        }\n                    }\n                }\n                else if (mdBlocks.type === \"toggle\") {\n                    // convert children md object to md string\n                    const toggle_children_md_string = this.toMarkdownString(mdBlocks.children);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    mdOutput[pageIdentifier] += md.toggle(mdBlocks.parent, toggle_children_md_string[\"parent\"]);\n                }\n                else {\n                    let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier, nestingLevel + 1);\n                    mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n                    if (pageIdentifier !== \"parent\" && mdstr[\"parent\"]) {\n                        mdOutput[pageIdentifier] += mdstr[\"parent\"];\n                    }\n                    else if (mdstr[pageIdentifier]) {\n                        mdOutput[pageIdentifier] += mdstr[pageIdentifier];\n                    }\n                }\n            }\n        });\n        return mdOutput;\n    }\n    /**\n     * Retrieves Notion Blocks based on ID and converts them to Markdown Blocks\n     * @param {string} id - notion page id (not database id)\n     * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100 (Default=null)\n     * @returns {Promise<MdBlock[]>} - List of markdown blocks\n     */\n    async pageToMarkdown(id, totalPage = null) {\n        if (!this.notionClient) {\n            throw new Error(\"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\");\n        }\n        const blocks = await (0, notion_1.getBlockChildren)(this.notionClient, id, totalPage);\n        const parsedData = await this.blocksToMarkdown(blocks);\n        return parsedData;\n    }\n    /**\n     * Converts list of Notion Blocks to Markdown Blocks\n     * @param {ListBlockChildrenResponseResults | undefined} blocks - List of notion blocks\n     * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100\n     * @param {MdBlock[]} mdBlocks - Defines max depth of nesting\n     * @returns {Promise<MdBlock[]>} - Array of markdown blocks with their children\n     */\n    async blocksToMarkdown(blocks, totalPage = null, mdBlocks = []) {\n        var _a, _b;\n        if (!this.notionClient) {\n            throw new Error(\"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\");\n        }\n        if (!blocks)\n            return mdBlocks;\n        for (let i = 0; i < blocks.length; i++) {\n            let block = blocks[i];\n            // @ts-ignore\n            if (block.type === \"child_page\" && !this.config.parseChildPages) {\n                continue;\n            }\n            if (\"has_children\" in block && block.has_children) {\n                const block_id = block.type == \"synced_block\" &&\n                    ((_b = (_a = block.synced_block) === null || _a === void 0 ? void 0 : _a.synced_from) === null || _b === void 0 ? void 0 : _b.block_id)\n                    ? block.synced_block.synced_from.block_id\n                    : block.id;\n                // Get children of this block.\n                let child_blocks = await (0, notion_1.getBlockChildren)(this.notionClient, block_id, totalPage);\n                // Push this block to mdBlocks.\n                mdBlocks.push({\n                    type: block.type,\n                    blockId: block.id,\n                    parent: await this.blockToMarkdown(block),\n                    children: [],\n                });\n                // Recursively call blocksToMarkdown to get children of this block.\n                // check for custom transformer before parsing child\n                if (!(block.type in this.customTransformers) &&\n                    !this.customTransformers[block.type]) {\n                    let l = mdBlocks.length;\n                    await this.blocksToMarkdown(child_blocks, totalPage, mdBlocks[l - 1].children);\n                }\n                continue;\n            }\n            let tmp = await this.blockToMarkdown(block);\n            mdBlocks.push({\n                // @ts-ignore\n                type: block.type,\n                blockId: block.id,\n                parent: tmp,\n                children: [],\n            });\n        }\n        return mdBlocks;\n    }\n    /**\n     * Converts a Notion Block to a Markdown Block\n     * @param {ListBlockChildrenResponseResult} block - single notion block\n     * @returns {string} corresponding markdown string of the passed block\n     */\n    async blockToMarkdown(block) {\n        if (typeof block !== \"object\" || !(\"type\" in block))\n            return \"\";\n        let parsedData = \"\";\n        const { type } = block;\n        if (type in this.customTransformers && !!this.customTransformers[type]) {\n            const customTransformerValue = await this.customTransformers[type](block);\n            if (typeof customTransformerValue === \"string\")\n                return customTransformerValue;\n        }\n        switch (type) {\n            case \"image\":\n                {\n                    let blockContent = block.image;\n                    let image_title = \"image\";\n                    const image_caption_plain = blockContent.caption\n                        .map((item) => item.plain_text)\n                        .join(\"\");\n                    const image_type = blockContent.type;\n                    let link = \"\";\n                    if (image_type === \"external\") {\n                        link = blockContent.external.url;\n                    }\n                    if (image_type === \"file\") {\n                        link = blockContent.file.url;\n                    }\n                    // image caption with high priority\n                    if (image_caption_plain.trim().length > 0) {\n                        image_title = image_caption_plain;\n                    }\n                    else if (image_type === \"file\" || image_type === \"external\") {\n                        const matches = link.match(/[^\\/\\\\&\\?]+\\.\\w{3,4}(?=([\\?&].*$|$))/);\n                        image_title = matches ? matches[0] : image_title;\n                    }\n                    return await md.image(image_title, link, this.config.convertImagesToBase64);\n                }\n                break;\n            case \"divider\": {\n                return md.divider();\n            }\n            case \"equation\": {\n                return md.equation(block.equation.expression);\n            }\n            case \"video\":\n            case \"file\":\n            case \"pdf\":\n                {\n                    let blockContent;\n                    let title = type;\n                    if (type === \"video\")\n                        blockContent = block.video;\n                    if (type === \"file\")\n                        blockContent = block.file;\n                    if (type === \"pdf\")\n                        blockContent = block.pdf;\n                    const caption = blockContent === null || blockContent === void 0 ? void 0 : blockContent.caption.map((item) => item.plain_text).join(\"\");\n                    if (blockContent) {\n                        const file_type = blockContent.type;\n                        let link = \"\";\n                        if (file_type === \"external\")\n                            link = blockContent.external.url;\n                        if (file_type === \"file\")\n                            link = blockContent.file.url;\n                        if (caption && caption.trim().length > 0) {\n                            title = caption;\n                        }\n                        else if (link) {\n                            const matches = link.match(/[^\\/\\\\&\\?]+\\.\\w{3,4}(?=([\\?&].*$|$))/);\n                            title = matches ? matches[0] : type;\n                        }\n                        return md.link(title, link);\n                    }\n                }\n                break;\n            case \"bookmark\":\n            case \"embed\":\n            case \"link_preview\":\n            case \"link_to_page\":\n                {\n                    let blockContent;\n                    let title = type;\n                    if (type === \"bookmark\")\n                        blockContent = block.bookmark;\n                    if (type === \"embed\")\n                        blockContent = block.embed;\n                    if (type === \"link_preview\")\n                        blockContent = block.link_preview;\n                    if (type === \"link_to_page\" &&\n                        block.link_to_page.type === \"page_id\") {\n                        blockContent = { url: block.link_to_page.page_id };\n                    }\n                    if (blockContent)\n                        return md.link(title, blockContent.url);\n                }\n                break;\n            case \"child_page\":\n                {\n                    if (!this.config.parseChildPages)\n                        return \"\";\n                    let pageTitle = block.child_page.title;\n                    if (this.config.separateChildPage) {\n                        return pageTitle;\n                    }\n                    return md.heading2(pageTitle);\n                }\n                break;\n            case \"child_database\":\n                {\n                    let pageTitle = block.child_database.title || `child_database`;\n                    return pageTitle;\n                }\n                break;\n            case \"table\": {\n                const { id, has_children } = block;\n                let tableArr = [];\n                if (has_children) {\n                    const tableRows = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);\n                    let rowsPromise = tableRows === null || tableRows === void 0 ? void 0 : tableRows.map(async (row) => {\n                        const { type } = row;\n                        const cells = row[type][\"cells\"];\n                        /**\n                         * this is more like a hack since matching the type text was\n                         * difficult. So converting each cell to paragraph type to\n                         * reuse the blockToMarkdown function\n                         */\n                        let cellStringPromise = cells.map(async (cell) => await this.blockToMarkdown({\n                            type: \"paragraph\",\n                            paragraph: { rich_text: cell },\n                        }));\n                        const cellStringArr = await Promise.all(cellStringPromise);\n                        tableArr.push(cellStringArr);\n                    });\n                    await Promise.all(rowsPromise || []);\n                }\n                return md.table(tableArr);\n            }\n            // Rest of the types\n            // \"paragraph\"\n            // \"heading_1\"\n            // \"heading_2\"\n            // \"heading_3\"\n            // \"bulleted_list_item\"\n            // \"numbered_list_item\"\n            // \"quote\"\n            // \"to_do\"\n            // \"template\"\n            // \"synced_block\"\n            // \"child_page\"\n            // \"child_database\"\n            // \"code\"\n            // \"callout\"\n            // \"breadcrumb\"\n            // \"table_of_contents\"\n            // \"link_to_page\"\n            // \"audio\"\n            // \"unsupported\"\n            default: {\n                // In this case typescript is not able to index the types properly, hence ignoring the error\n                // @ts-ignore\n                let blockContent = block[type].text || block[type].rich_text || [];\n                blockContent.map((content) => {\n                    if (content.type === \"equation\") {\n                        parsedData += md.inlineEquation(content.equation.expression);\n                        return;\n                    }\n                    const annotations = content.annotations;\n                    let plain_text = content.plain_text;\n                    plain_text = this.annotatePlainText(plain_text, annotations);\n                    if (content[\"href\"])\n                        plain_text = md.link(plain_text, content[\"href\"]);\n                    parsedData += plain_text;\n                });\n            }\n        }\n        switch (type) {\n            case \"code\":\n                {\n                    parsedData = md.codeBlock(parsedData, block[type].language);\n                }\n                break;\n            case \"heading_1\":\n                {\n                    parsedData = md.heading1(parsedData);\n                }\n                break;\n            case \"heading_2\":\n                {\n                    parsedData = md.heading2(parsedData);\n                }\n                break;\n            case \"heading_3\":\n                {\n                    parsedData = md.heading3(parsedData);\n                }\n                break;\n            case \"quote\":\n                {\n                    parsedData = md.quote(parsedData);\n                }\n                break;\n            case \"callout\":\n                {\n                    const { id, has_children } = block;\n                    let callout_string = \"\";\n                    if (!has_children) {\n                        return md.callout(parsedData, block[type].icon);\n                    }\n                    const callout_children_object = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);\n                    // // parse children blocks to md object\n                    const callout_children = await this.blocksToMarkdown(callout_children_object);\n                    callout_string += `${parsedData}\\n`;\n                    callout_children.map((child) => {\n                        callout_string += `${child.parent}\\n\\n`;\n                    });\n                    parsedData = md.callout(callout_string.trim(), block[type].icon);\n                }\n                break;\n            case \"bulleted_list_item\":\n                {\n                    parsedData = md.bullet(parsedData);\n                }\n                break;\n            case \"numbered_list_item\":\n                {\n                    parsedData = md.bullet(parsedData, block.numbered_list_item.number);\n                }\n                break;\n            case \"to_do\":\n                {\n                    parsedData = md.todo(parsedData, block.to_do.checked);\n                }\n                break;\n        }\n        return parsedData;\n    }\n    /**\n     * Annoate text using provided annotations\n     * @param {string} text - String to be annotated\n     * @param {Annotations} annotations - Annotation object of a notion block\n     * @returns {string} - Annotated text\n     */\n    annotatePlainText(text, annotations) {\n        // if text is all spaces, don't annotate\n        if (text.match(/^\\s*$/))\n            return text;\n        const leadingSpaceMatch = text.match(/^(\\s*)/);\n        const trailingSpaceMatch = text.match(/(\\s*)$/);\n        const leading_space = leadingSpaceMatch ? leadingSpaceMatch[0] : \"\";\n        const trailing_space = trailingSpaceMatch ? trailingSpaceMatch[0] : \"\";\n        text = text.trim();\n        if (text !== \"\") {\n            if (annotations.code)\n                text = md.inlineCode(text);\n            if (annotations.bold)\n                text = md.bold(text);\n            if (annotations.italic)\n                text = md.italic(text);\n            if (annotations.strikethrough)\n                text = md.strikethrough(text);\n            if (annotations.underline)\n                text = md.underline(text);\n        }\n        return leading_space + text + trailing_space;\n    }\n}\nexports.NotionToMarkdown = NotionToMarkdown;\n//# sourceMappingURL=notion-to-md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL25vdGlvbi10by1tZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLHdCQUF3QixtQkFBTyxDQUFDLHVFQUFZO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4Q0FBOEM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQThDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlLElBQUksc0JBQXNCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdELGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hELGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL25vdGlvbi10by1tZC5qcz8yYjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdGlvblRvTWFya2Rvd24gPSB2b2lkIDA7XG5jb25zdCBtZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy9tZFwiKSk7XG5jb25zdCBub3Rpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL25vdGlvblwiKTtcbi8qKlxuICogQ29udmVydHMgYSBOb3Rpb24gcGFnZSB0byBNYXJrZG93bi5cbiAqL1xuY2xhc3MgTm90aW9uVG9NYXJrZG93biB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm5vdGlvbkNsaWVudCA9IG9wdGlvbnMubm90aW9uQ2xpZW50O1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgc2VwYXJhdGVDaGlsZFBhZ2U6IGZhbHNlLFxuICAgICAgICAgICAgY29udmVydEltYWdlc1RvQmFzZTY0OiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlQ2hpbGRQYWdlczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7IC4uLmRlZmF1bHRDb25maWcsIC4uLm9wdGlvbnMuY29uZmlnIH07XG4gICAgICAgIHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzID0ge307XG4gICAgfVxuICAgIHNldEN1c3RvbVRyYW5zZm9ybWVyKHR5cGUsIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzW3R5cGVdID0gdHJhbnNmb3JtZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBNYXJrZG93biBCbG9ja3MgdG8gc3RyaW5nXG4gICAgICogQHBhcmFtIHtNZEJsb2NrW119IG1kQmxvY2tzIC0gQXJyYXkgb2YgbWFya2Rvd24gYmxvY2tzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5lc3RpbmdMZXZlbCAtIERlZmluZXMgbWF4IGRlcHRoIG9mIG5lc3RpbmdcbiAgICAgKiBAcmV0dXJucyB7TWRTdHJpbmdPYmplY3R9IC0gUmV0dXJucyBtYXJrZG93biBzdHJpbmcgd2l0aCBjaGlsZCBwYWdlcyBzZXBhcmF0ZWRcbiAgICAgKi9cbiAgICB0b01hcmtkb3duU3RyaW5nKG1kQmxvY2tzID0gW10sIHBhZ2VJZGVudGlmaWVyID0gXCJwYXJlbnRcIiwgbmVzdGluZ0xldmVsID0gMCkge1xuICAgICAgICBsZXQgbWRPdXRwdXQgPSB7fTtcbiAgICAgICAgbWRCbG9ja3MuZm9yRWFjaCgobWRCbG9ja3MpID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHRvZ2dsZSBpbiB0aGUgY2hpbGQgYmxvY2tzIGxvZ2ljXG4gICAgICAgICAgICAvLyBhZGRpbmcgYSB0b2dnbGUgY2hlY2sgcHJldmVudHMgZHVwbGljYXRlXG4gICAgICAgICAgICAvLyByZW5kZXJpbmcgb2YgdG9nZ2xlIHRpdGxlXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHBhcmVudCBibG9ja3NcbiAgICAgICAgICAgIGlmIChtZEJsb2Nrcy5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICBtZEJsb2Nrcy50eXBlICE9PSBcInRvZ2dsZVwiICYmXG4gICAgICAgICAgICAgICAgbWRCbG9ja3MudHlwZSAhPT0gXCJjaGlsZF9wYWdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWRCbG9ja3MudHlwZSAhPT0gXCJ0b19kb1wiICYmXG4gICAgICAgICAgICAgICAgICAgIG1kQmxvY2tzLnR5cGUgIT09IFwiYnVsbGV0ZWRfbGlzdF9pdGVtXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgbWRCbG9ja3MudHlwZSAhPT0gXCJudW1iZXJlZF9saXN0X2l0ZW1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGlmIGtleSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSA9IG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZXh0cmEgbGluZSBicmVha3Mgbm9uIGxpc3QgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBgXFxuJHttZC5hZGRUYWJTcGFjZShtZEJsb2Nrcy5wYXJlbnQsIG5lc3RpbmdMZXZlbCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaWYga2V5IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdID0gbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBgJHttZC5hZGRUYWJTcGFjZShtZEJsb2Nrcy5wYXJlbnQsIG5lc3RpbmdMZXZlbCl9XFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9jZXNzIGNoaWxkIGJsb2Nrc1xuICAgICAgICAgICAgaWYgKG1kQmxvY2tzLmNoaWxkcmVuICYmIG1kQmxvY2tzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobWRCbG9ja3MudHlwZSA9PT0gXCJzeW5jZWRfYmxvY2tcIiB8fFxuICAgICAgICAgICAgICAgICAgICBtZEJsb2Nrcy50eXBlID09PSBcImNvbHVtbl9saXN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgbWRCbG9ja3MudHlwZSA9PT0gXCJjb2x1bW5cIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWRzdHIgPSB0aGlzLnRvTWFya2Rvd25TdHJpbmcobWRCbG9ja3MuY2hpbGRyZW4sIHBhZ2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdID0gbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1kc3RyKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZE91dHB1dFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRba2V5XSArPSBtZHN0cltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRba2V5XSA9IG1kc3RyW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZEJsb2Nrcy50eXBlID09PSBcImNoaWxkX3BhZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFBhZ2VUaXRsZSA9IG1kQmxvY2tzLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1kc3RyID0gdGhpcy50b01hcmtkb3duU3RyaW5nKG1kQmxvY2tzLmNoaWxkcmVuLCBjaGlsZFBhZ2VUaXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zZXBhcmF0ZUNoaWxkUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXQgPSB7IC4uLm1kT3V0cHV0LCAuLi5tZHN0ciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdID0gbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWRzdHJbY2hpbGRQYWdlVGl0bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgcGFnZSBoZWFkaW5nIGZvbGxvd2VkIGJ5IGNoaWxkIHBhZ2UgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBgXFxuJHtjaGlsZFBhZ2VUaXRsZX1cXG4ke21kc3RyW2NoaWxkUGFnZVRpdGxlXX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1kQmxvY2tzLnR5cGUgPT09IFwidG9nZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBjaGlsZHJlbiBtZCBvYmplY3QgdG8gbWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvZ2dsZV9jaGlsZHJlbl9tZF9zdHJpbmcgPSB0aGlzLnRvTWFya2Rvd25TdHJpbmcobWRCbG9ja3MuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gPSBtZE91dHB1dFtwYWdlSWRlbnRpZmllcl0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbWRPdXRwdXRbcGFnZUlkZW50aWZpZXJdICs9IG1kLnRvZ2dsZShtZEJsb2Nrcy5wYXJlbnQsIHRvZ2dsZV9jaGlsZHJlbl9tZF9zdHJpbmdbXCJwYXJlbnRcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1kc3RyID0gdGhpcy50b01hcmtkb3duU3RyaW5nKG1kQmxvY2tzLmNoaWxkcmVuLCBwYWdlSWRlbnRpZmllciwgbmVzdGluZ0xldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSA9IG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZUlkZW50aWZpZXIgIT09IFwicGFyZW50XCIgJiYgbWRzdHJbXCJwYXJlbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBtZHN0cltcInBhcmVudFwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZHN0cltwYWdlSWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kT3V0cHV0W3BhZ2VJZGVudGlmaWVyXSArPSBtZHN0cltwYWdlSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWRPdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBOb3Rpb24gQmxvY2tzIGJhc2VkIG9uIElEIGFuZCBjb252ZXJ0cyB0aGVtIHRvIE1hcmtkb3duIEJsb2Nrc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIG5vdGlvbiBwYWdlIGlkIChub3QgZGF0YWJhc2UgaWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsUGFnZSAtIFJldHJpZXZlIGJsb2NrIGNoaWxkcmVuIHJlcXVlc3QgbnVtYmVyLCBwYWdlX3NpemUgTWF4aW11bSA9IHRvdGFsUGFnZSAqIDEwMCAoRGVmYXVsdD1udWxsKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1kQmxvY2tbXT59IC0gTGlzdCBvZiBtYXJrZG93biBibG9ja3NcbiAgICAgKi9cbiAgICBhc3luYyBwYWdlVG9NYXJrZG93bihpZCwgdG90YWxQYWdlID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMubm90aW9uQ2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Rpb24gY2xpZW50IGlzIG5vdCBwcm92aWRlZCwgZm9yIG1vcmUgZGV0YWlscyBjaGVjayBvdXQgaHR0cHM6Ly9naXRodWIuY29tL3NvdXZpa2luYXRvci9ub3Rpb24tdG8tbWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tzID0gYXdhaXQgKDAsIG5vdGlvbl8xLmdldEJsb2NrQ2hpbGRyZW4pKHRoaXMubm90aW9uQ2xpZW50LCBpZCwgdG90YWxQYWdlKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IGF3YWl0IHRoaXMuYmxvY2tzVG9NYXJrZG93bihibG9ja3MpO1xuICAgICAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbGlzdCBvZiBOb3Rpb24gQmxvY2tzIHRvIE1hcmtkb3duIEJsb2Nrc1xuICAgICAqIEBwYXJhbSB7TGlzdEJsb2NrQ2hpbGRyZW5SZXNwb25zZVJlc3VsdHMgfCB1bmRlZmluZWR9IGJsb2NrcyAtIExpc3Qgb2Ygbm90aW9uIGJsb2Nrc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFBhZ2UgLSBSZXRyaWV2ZSBibG9jayBjaGlsZHJlbiByZXF1ZXN0IG51bWJlciwgcGFnZV9zaXplIE1heGltdW0gPSB0b3RhbFBhZ2UgKiAxMDBcbiAgICAgKiBAcGFyYW0ge01kQmxvY2tbXX0gbWRCbG9ja3MgLSBEZWZpbmVzIG1heCBkZXB0aCBvZiBuZXN0aW5nXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWRCbG9ja1tdPn0gLSBBcnJheSBvZiBtYXJrZG93biBibG9ja3Mgd2l0aCB0aGVpciBjaGlsZHJlblxuICAgICAqL1xuICAgIGFzeW5jIGJsb2Nrc1RvTWFya2Rvd24oYmxvY2tzLCB0b3RhbFBhZ2UgPSBudWxsLCBtZEJsb2NrcyA9IFtdKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5ub3Rpb25DbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdGlvbiBjbGllbnQgaXMgbm90IHByb3ZpZGVkLCBmb3IgbW9yZSBkZXRhaWxzIGNoZWNrIG91dCBodHRwczovL2dpdGh1Yi5jb20vc291dmlraW5hdG9yL25vdGlvbi10by1tZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJsb2NrcylcbiAgICAgICAgICAgIHJldHVybiBtZEJsb2NrcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSBcImNoaWxkX3BhZ2VcIiAmJiAhdGhpcy5jb25maWcucGFyc2VDaGlsZFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJoYXNfY2hpbGRyZW5cIiBpbiBibG9jayAmJiBibG9jay5oYXNfY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja19pZCA9IGJsb2NrLnR5cGUgPT0gXCJzeW5jZWRfYmxvY2tcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gYmxvY2suc3luY2VkX2Jsb2NrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3luY2VkX2Zyb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja19pZClcbiAgICAgICAgICAgICAgICAgICAgPyBibG9jay5zeW5jZWRfYmxvY2suc3luY2VkX2Zyb20uYmxvY2tfaWRcbiAgICAgICAgICAgICAgICAgICAgOiBibG9jay5pZDtcbiAgICAgICAgICAgICAgICAvLyBHZXQgY2hpbGRyZW4gb2YgdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRfYmxvY2tzID0gYXdhaXQgKDAsIG5vdGlvbl8xLmdldEJsb2NrQ2hpbGRyZW4pKHRoaXMubm90aW9uQ2xpZW50LCBibG9ja19pZCwgdG90YWxQYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBQdXNoIHRoaXMgYmxvY2sgdG8gbWRCbG9ja3MuXG4gICAgICAgICAgICAgICAgbWRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGJsb2NrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGF3YWl0IHRoaXMuYmxvY2tUb01hcmtkb3duKGJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgYmxvY2tzVG9NYXJrZG93biB0byBnZXQgY2hpbGRyZW4gb2YgdGhpcyBibG9jay5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY3VzdG9tIHRyYW5zZm9ybWVyIGJlZm9yZSBwYXJzaW5nIGNoaWxkXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxvY2sudHlwZSBpbiB0aGlzLmN1c3RvbVRyYW5zZm9ybWVycykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzW2Jsb2NrLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gbWRCbG9ja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJsb2Nrc1RvTWFya2Rvd24oY2hpbGRfYmxvY2tzLCB0b3RhbFBhZ2UsIG1kQmxvY2tzW2wgLSAxXS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRtcCA9IGF3YWl0IHRoaXMuYmxvY2tUb01hcmtkb3duKGJsb2NrKTtcbiAgICAgICAgICAgIG1kQmxvY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0eXBlOiBibG9jay50eXBlLFxuICAgICAgICAgICAgICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdG1wLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZEJsb2NrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBOb3Rpb24gQmxvY2sgdG8gYSBNYXJrZG93biBCbG9ja1xuICAgICAqIEBwYXJhbSB7TGlzdEJsb2NrQ2hpbGRyZW5SZXNwb25zZVJlc3VsdH0gYmxvY2sgLSBzaW5nbGUgbm90aW9uIGJsb2NrXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29ycmVzcG9uZGluZyBtYXJrZG93biBzdHJpbmcgb2YgdGhlIHBhc3NlZCBibG9ja1xuICAgICAqL1xuICAgIGFzeW5jIGJsb2NrVG9NYXJrZG93bihibG9jaykge1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0eXBlXCIgaW4gYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCBwYXJzZWREYXRhID0gXCJcIjtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBibG9jaztcbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5jdXN0b21UcmFuc2Zvcm1lcnMgJiYgISF0aGlzLmN1c3RvbVRyYW5zZm9ybWVyc1t0eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZSA9IGF3YWl0IHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJzW3R5cGVdKGJsb2NrKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tVHJhbnNmb3JtZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrQ29udGVudCA9IGJsb2NrLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VfdGl0bGUgPSBcImltYWdlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlX2NhcHRpb25fcGxhaW4gPSBibG9ja0NvbnRlbnQuY2FwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5wbGFpbl90ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlX3R5cGUgPSBibG9ja0NvbnRlbnQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VfdHlwZSA9PT0gXCJleHRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rID0gYmxvY2tDb250ZW50LmV4dGVybmFsLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VfdHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsgPSBibG9ja0NvbnRlbnQuZmlsZS51cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UgY2FwdGlvbiB3aXRoIGhpZ2ggcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlX2NhcHRpb25fcGxhaW4udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlX3RpdGxlID0gaW1hZ2VfY2FwdGlvbl9wbGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWFnZV90eXBlID09PSBcImZpbGVcIiB8fCBpbWFnZV90eXBlID09PSBcImV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5rLm1hdGNoKC9bXlxcL1xcXFwmXFw/XStcXC5cXHd7Myw0fSg/PShbXFw/Jl0uKiR8JCkpLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV90aXRsZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogaW1hZ2VfdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1kLmltYWdlKGltYWdlX3RpdGxlLCBsaW5rLCB0aGlzLmNvbmZpZy5jb252ZXJ0SW1hZ2VzVG9CYXNlNjQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkaXZpZGVyXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWQuZGl2aWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVxdWF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWQuZXF1YXRpb24oYmxvY2suZXF1YXRpb24uZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwicGRmXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ2aWRlb1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2sudmlkZW87XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZpbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29udGVudCA9IGJsb2NrLmZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInBkZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2sucGRmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0aW9uID0gYmxvY2tDb250ZW50ID09PSBudWxsIHx8IGJsb2NrQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tDb250ZW50LmNhcHRpb24ubWFwKChpdGVtKSA9PiBpdGVtLnBsYWluX3RleHQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVfdHlwZSA9IGJsb2NrQ29udGVudC50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVfdHlwZSA9PT0gXCJleHRlcm5hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsgPSBibG9ja0NvbnRlbnQuZXh0ZXJuYWwudXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVfdHlwZSA9PT0gXCJmaWxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluayA9IGJsb2NrQ29udGVudC5maWxlLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0aW9uICYmIGNhcHRpb24udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGxpbmsubWF0Y2goL1teXFwvXFxcXCZcXD9dK1xcLlxcd3szLDR9KD89KFtcXD8mXS4qJHwkKSkvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZC5saW5rKHRpdGxlLCBsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29rbWFya1wiOlxuICAgICAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibGlua19wcmV2aWV3XCI6XG4gICAgICAgICAgICBjYXNlIFwibGlua190b19wYWdlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJib29rbWFya1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tDb250ZW50ID0gYmxvY2suYm9va21hcms7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImVtYmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQgPSBibG9jay5lbWJlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibGlua19wcmV2aWV3XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQgPSBibG9jay5saW5rX3ByZXZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImxpbmtfdG9fcGFnZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5saW5rX3RvX3BhZ2UudHlwZSA9PT0gXCJwYWdlX2lkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29udGVudCA9IHsgdXJsOiBibG9jay5saW5rX3RvX3BhZ2UucGFnZV9pZCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWQubGluayh0aXRsZSwgYmxvY2tDb250ZW50LnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkX3BhZ2VcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25maWcucGFyc2VDaGlsZFBhZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWdlVGl0bGUgPSBibG9jay5jaGlsZF9wYWdlLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc2VwYXJhdGVDaGlsZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWdlVGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1kLmhlYWRpbmcyKHBhZ2VUaXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkX2RhdGFiYXNlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFnZVRpdGxlID0gYmxvY2suY2hpbGRfZGF0YWJhc2UudGl0bGUgfHwgYGNoaWxkX2RhdGFiYXNlYDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2VUaXRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidGFibGVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGhhc19jaGlsZHJlbiB9ID0gYmxvY2s7XG4gICAgICAgICAgICAgICAgbGV0IHRhYmxlQXJyID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGhhc19jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZVJvd3MgPSBhd2FpdCAoMCwgbm90aW9uXzEuZ2V0QmxvY2tDaGlsZHJlbikodGhpcy5ub3Rpb25DbGllbnQsIGlkLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm93c1Byb21pc2UgPSB0YWJsZVJvd3MgPT09IG51bGwgfHwgdGFibGVSb3dzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVJvd3MubWFwKGFzeW5jIChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbHMgPSByb3dbdHlwZV1bXCJjZWxsc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcyBpcyBtb3JlIGxpa2UgYSBoYWNrIHNpbmNlIG1hdGNoaW5nIHRoZSB0eXBlIHRleHQgd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBkaWZmaWN1bHQuIFNvIGNvbnZlcnRpbmcgZWFjaCBjZWxsIHRvIHBhcmFncmFwaCB0eXBlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZXVzZSB0aGUgYmxvY2tUb01hcmtkb3duIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsU3RyaW5nUHJvbWlzZSA9IGNlbGxzLm1hcChhc3luYyAoY2VsbCkgPT4gYXdhaXQgdGhpcy5ibG9ja1RvTWFya2Rvd24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7IHJpY2hfdGV4dDogY2VsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbFN0cmluZ0FyciA9IGF3YWl0IFByb21pc2UuYWxsKGNlbGxTdHJpbmdQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQXJyLnB1c2goY2VsbFN0cmluZ0Fycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyb3dzUHJvbWlzZSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZC50YWJsZSh0YWJsZUFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXN0IG9mIHRoZSB0eXBlc1xuICAgICAgICAgICAgLy8gXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzFcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzJcIlxuICAgICAgICAgICAgLy8gXCJoZWFkaW5nXzNcIlxuICAgICAgICAgICAgLy8gXCJidWxsZXRlZF9saXN0X2l0ZW1cIlxuICAgICAgICAgICAgLy8gXCJudW1iZXJlZF9saXN0X2l0ZW1cIlxuICAgICAgICAgICAgLy8gXCJxdW90ZVwiXG4gICAgICAgICAgICAvLyBcInRvX2RvXCJcbiAgICAgICAgICAgIC8vIFwidGVtcGxhdGVcIlxuICAgICAgICAgICAgLy8gXCJzeW5jZWRfYmxvY2tcIlxuICAgICAgICAgICAgLy8gXCJjaGlsZF9wYWdlXCJcbiAgICAgICAgICAgIC8vIFwiY2hpbGRfZGF0YWJhc2VcIlxuICAgICAgICAgICAgLy8gXCJjb2RlXCJcbiAgICAgICAgICAgIC8vIFwiY2FsbG91dFwiXG4gICAgICAgICAgICAvLyBcImJyZWFkY3J1bWJcIlxuICAgICAgICAgICAgLy8gXCJ0YWJsZV9vZl9jb250ZW50c1wiXG4gICAgICAgICAgICAvLyBcImxpbmtfdG9fcGFnZVwiXG4gICAgICAgICAgICAvLyBcImF1ZGlvXCJcbiAgICAgICAgICAgIC8vIFwidW5zdXBwb3J0ZWRcIlxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB0eXBlc2NyaXB0IGlzIG5vdCBhYmxlIHRvIGluZGV4IHRoZSB0eXBlcyBwcm9wZXJseSwgaGVuY2UgaWdub3JpbmcgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBibG9ja0NvbnRlbnQgPSBibG9ja1t0eXBlXS50ZXh0IHx8IGJsb2NrW3R5cGVdLnJpY2hfdGV4dCB8fCBbXTtcbiAgICAgICAgICAgICAgICBibG9ja0NvbnRlbnQubWFwKChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT09IFwiZXF1YXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSArPSBtZC5pbmxpbmVFcXVhdGlvbihjb250ZW50LmVxdWF0aW9uLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gY29udGVudC5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYWluX3RleHQgPSBjb250ZW50LnBsYWluX3RleHQ7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluX3RleHQgPSB0aGlzLmFubm90YXRlUGxhaW5UZXh0KHBsYWluX3RleHQsIGFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbXCJocmVmXCJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhaW5fdGV4dCA9IG1kLmxpbmsocGxhaW5fdGV4dCwgY29udGVudFtcImhyZWZcIl0pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhICs9IHBsYWluX3RleHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLmNvZGVCbG9jayhwYXJzZWREYXRhLCBibG9ja1t0eXBlXS5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImhlYWRpbmdfMVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLmhlYWRpbmcxKHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoZWFkaW5nXzJcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5oZWFkaW5nMihwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaGVhZGluZ18zXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQuaGVhZGluZzMocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInF1b3RlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQucXVvdGUocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxvdXRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGhhc19jaGlsZHJlbiB9ID0gYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWxsb3V0X3N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWQuY2FsbG91dChwYXJzZWREYXRhLCBibG9ja1t0eXBlXS5pY29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsb3V0X2NoaWxkcmVuX29iamVjdCA9IGF3YWl0ICgwLCBub3Rpb25fMS5nZXRCbG9ja0NoaWxkcmVuKSh0aGlzLm5vdGlvbkNsaWVudCwgaWQsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIHBhcnNlIGNoaWxkcmVuIGJsb2NrcyB0byBtZCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbG91dF9jaGlsZHJlbiA9IGF3YWl0IHRoaXMuYmxvY2tzVG9NYXJrZG93bihjYWxsb3V0X2NoaWxkcmVuX29iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxvdXRfc3RyaW5nICs9IGAke3BhcnNlZERhdGF9XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbG91dF9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsb3V0X3N0cmluZyArPSBgJHtjaGlsZC5wYXJlbnR9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBtZC5jYWxsb3V0KGNhbGxvdXRfc3RyaW5nLnRyaW0oKSwgYmxvY2tbdHlwZV0uaWNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ1bGxldGVkX2xpc3RfaXRlbVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLmJ1bGxldChwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyZWRfbGlzdF9pdGVtXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gbWQuYnVsbGV0KHBhcnNlZERhdGEsIGJsb2NrLm51bWJlcmVkX2xpc3RfaXRlbS5udW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b19kb1wiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IG1kLnRvZG8ocGFyc2VkRGF0YSwgYmxvY2sudG9fZG8uY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbm5vYXRlIHRleHQgdXNpbmcgcHJvdmlkZWQgYW5ub3RhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFN0cmluZyB0byBiZSBhbm5vdGF0ZWRcbiAgICAgKiBAcGFyYW0ge0Fubm90YXRpb25zfSBhbm5vdGF0aW9ucyAtIEFubm90YXRpb24gb2JqZWN0IG9mIGEgbm90aW9uIGJsb2NrXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBBbm5vdGF0ZWQgdGV4dFxuICAgICAqL1xuICAgIGFubm90YXRlUGxhaW5UZXh0KHRleHQsIGFubm90YXRpb25zKSB7XG4gICAgICAgIC8vIGlmIHRleHQgaXMgYWxsIHNwYWNlcywgZG9uJ3QgYW5ub3RhdGVcbiAgICAgICAgaWYgKHRleHQubWF0Y2goL15cXHMqJC8pKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZU1hdGNoID0gdGV4dC5tYXRjaCgvXihcXHMqKS8pO1xuICAgICAgICBjb25zdCB0cmFpbGluZ1NwYWNlTWF0Y2ggPSB0ZXh0Lm1hdGNoKC8oXFxzKikkLyk7XG4gICAgICAgIGNvbnN0IGxlYWRpbmdfc3BhY2UgPSBsZWFkaW5nU3BhY2VNYXRjaCA/IGxlYWRpbmdTcGFjZU1hdGNoWzBdIDogXCJcIjtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdfc3BhY2UgPSB0cmFpbGluZ1NwYWNlTWF0Y2ggPyB0cmFpbGluZ1NwYWNlTWF0Y2hbMF0gOiBcIlwiO1xuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuY29kZSlcbiAgICAgICAgICAgICAgICB0ZXh0ID0gbWQuaW5saW5lQ29kZSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5ib2xkKVxuICAgICAgICAgICAgICAgIHRleHQgPSBtZC5ib2xkKHRleHQpO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLml0YWxpYylcbiAgICAgICAgICAgICAgICB0ZXh0ID0gbWQuaXRhbGljKHRleHQpO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLnN0cmlrZXRocm91Z2gpXG4gICAgICAgICAgICAgICAgdGV4dCA9IG1kLnN0cmlrZXRocm91Z2godGV4dCk7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMudW5kZXJsaW5lKVxuICAgICAgICAgICAgICAgIHRleHQgPSBtZC51bmRlcmxpbmUodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlYWRpbmdfc3BhY2UgKyB0ZXh0ICsgdHJhaWxpbmdfc3BhY2U7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3Rpb25Ub01hcmtkb3duID0gTm90aW9uVG9NYXJrZG93bjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlvbi10by1tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/notion-to-md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/utils/md.js":
/*!*****************************************************!*\
  !*** ./node_modules/notion-to-md/build/utils/md.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.table = exports.toggle = exports.divider = exports.addTabSpace = exports.image = exports.todo = exports.bullet = exports.callout = exports.quote = exports.heading3 = exports.heading2 = exports.heading1 = exports.equation = exports.codeBlock = exports.link = exports.underline = exports.strikethrough = exports.italic = exports.bold = exports.inlineEquation = exports.inlineCode = void 0;\nconst markdown_table_1 = __importDefault(__webpack_require__(/*! markdown-table */ \"(rsc)/./node_modules/markdown-table/index.js\"));\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"));\nconst inlineCode = (text) => {\n    return `\\`${text}\\``;\n};\nexports.inlineCode = inlineCode;\nconst inlineEquation = (text) => {\n    return `$${text}$`;\n};\nexports.inlineEquation = inlineEquation;\nconst bold = (text) => {\n    return `**${text}**`;\n};\nexports.bold = bold;\nconst italic = (text) => {\n    return `_${text}_`;\n};\nexports.italic = italic;\nconst strikethrough = (text) => {\n    return `~~${text}~~`;\n};\nexports.strikethrough = strikethrough;\nconst underline = (text) => {\n    return `<u>${text}</u>`;\n};\nexports.underline = underline;\nconst link = (text, href) => {\n    return `[${text}](${href})`;\n};\nexports.link = link;\nconst codeBlock = (text, language) => {\n    if (language === \"plain text\")\n        language = \"text\";\n    return `\\`\\`\\`${language}\n${text}\n\\`\\`\\``;\n};\nexports.codeBlock = codeBlock;\nconst equation = (text) => {\n    return `$$\n${text}\n$$`;\n};\nexports.equation = equation;\nconst heading1 = (text) => {\n    return `# ${text}`;\n};\nexports.heading1 = heading1;\nconst heading2 = (text) => {\n    return `## ${text}`;\n};\nexports.heading2 = heading2;\nconst heading3 = (text) => {\n    return `### ${text}`;\n};\nexports.heading3 = heading3;\nconst quote = (text) => {\n    // the replace is done to handle multiple lines\n    return `> ${text.replace(/\\n/g, \"  \\n> \")}`;\n};\nexports.quote = quote;\nconst callout = (text, icon) => {\n    let emoji;\n    if ((icon === null || icon === void 0 ? void 0 : icon.type) === \"emoji\") {\n        emoji = icon.emoji;\n    }\n    // the replace is done to handle multiple lines\n    return `> ${emoji ? emoji + \" \" : \"\"}${text.replace(/\\n/g, \"  \\n> \")}`;\n};\nexports.callout = callout;\nconst bullet = (text, count) => {\n    let renderText = text.trim();\n    return count ? `${count}. ${renderText}` : `- ${renderText}`;\n};\nexports.bullet = bullet;\nconst todo = (text, checked) => {\n    return checked ? `- [x] ${text}` : `- [ ] ${text}`;\n};\nexports.todo = todo;\nconst image = async (alt, href, convertToBase64 = false) => {\n    // In case the user does not want to convert the images to Base64\n    // or the image is already base64\n    if (!convertToBase64 || href.startsWith(\"data:\")) {\n        if (href.startsWith(\"data:\")) {\n            // Extract base64 data, i.e. the string after 'data:mime/type;base64,'\n            const base64 = href.split(\",\").pop();\n            // This overrides incorrect data: string format to png\n            // so that browsers can correctly render the data\n            return `![${alt}](data:image/png;base64,${base64})`;\n        }\n        return `![${alt}](${href})`;\n    }\n    else {\n        // Otherwise, download the image and convert it to base64\n        const res = await (0, node_fetch_1.default)(href);\n        const buf = await res.arrayBuffer();\n        const base64 = Buffer.from(buf).toString(\"base64\");\n        return `![${alt}](data:image/png;base64,${base64})`;\n    }\n};\nexports.image = image;\nconst addTabSpace = (text, n = 0) => {\n    const tab = \"\t\";\n    for (let i = 0; i < n; i++) {\n        if (text.includes(\"\\n\")) {\n            const multiLineText = text.split(/(?:^|\\n)/).join(`\\n${tab}`);\n            text = tab + multiLineText;\n        }\n        else\n            text = tab + text;\n    }\n    return text;\n};\nexports.addTabSpace = addTabSpace;\nconst divider = () => {\n    return \"---\";\n};\nexports.divider = divider;\nconst toggle = (summary, children) => {\n    if (!summary)\n        return children || \"\";\n    return `<details>\n<summary>${summary}</summary>\n${children || \"\"}\n</details>\\n\\n`;\n};\nexports.toggle = toggle;\nconst table = (cells) => {\n    return (0, markdown_table_1.default)(cells);\n};\nexports.table = table;\n//# sourceMappingURL=md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL21kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0I7QUFDalkseUNBQXlDLG1CQUFPLENBQUMsb0VBQWdCO0FBQ2pFLHFDQUFxQyxtQkFBTyxDQUFDLGlFQUFZO0FBQ3pEO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlLEtBQUssSUFBSSxLQUFLO0FBQzdCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixFQUFFO0FBQ0Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QixFQUFFLDhCQUE4QjtBQUN6RTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sSUFBSSxXQUFXLFNBQVMsV0FBVztBQUMvRDtBQUNBLGNBQWM7QUFDZDtBQUNBLDhCQUE4QixLQUFLLGFBQWEsS0FBSztBQUNyRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLGlCQUFpQixTQUFTLE9BQU87QUFDN0Q7QUFDQSxvQkFBb0IsSUFBSSxJQUFJLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUksaUJBQWlCLFNBQVMsT0FBTztBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG1FQUFtRSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixFQUFFO0FBQ0Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL21kLmpzPzE3MDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRhYmxlID0gZXhwb3J0cy50b2dnbGUgPSBleHBvcnRzLmRpdmlkZXIgPSBleHBvcnRzLmFkZFRhYlNwYWNlID0gZXhwb3J0cy5pbWFnZSA9IGV4cG9ydHMudG9kbyA9IGV4cG9ydHMuYnVsbGV0ID0gZXhwb3J0cy5jYWxsb3V0ID0gZXhwb3J0cy5xdW90ZSA9IGV4cG9ydHMuaGVhZGluZzMgPSBleHBvcnRzLmhlYWRpbmcyID0gZXhwb3J0cy5oZWFkaW5nMSA9IGV4cG9ydHMuZXF1YXRpb24gPSBleHBvcnRzLmNvZGVCbG9jayA9IGV4cG9ydHMubGluayA9IGV4cG9ydHMudW5kZXJsaW5lID0gZXhwb3J0cy5zdHJpa2V0aHJvdWdoID0gZXhwb3J0cy5pdGFsaWMgPSBleHBvcnRzLmJvbGQgPSBleHBvcnRzLmlubGluZUVxdWF0aW9uID0gZXhwb3J0cy5pbmxpbmVDb2RlID0gdm9pZCAwO1xuY29uc3QgbWFya2Rvd25fdGFibGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWFya2Rvd24tdGFibGVcIikpO1xuY29uc3Qgbm9kZV9mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlLWZldGNoXCIpKTtcbmNvbnN0IGlubGluZUNvZGUgPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgXFxgJHt0ZXh0fVxcYGA7XG59O1xuZXhwb3J0cy5pbmxpbmVDb2RlID0gaW5saW5lQ29kZTtcbmNvbnN0IGlubGluZUVxdWF0aW9uID0gKHRleHQpID0+IHtcbiAgICByZXR1cm4gYCQke3RleHR9JGA7XG59O1xuZXhwb3J0cy5pbmxpbmVFcXVhdGlvbiA9IGlubGluZUVxdWF0aW9uO1xuY29uc3QgYm9sZCA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGAqKiR7dGV4dH0qKmA7XG59O1xuZXhwb3J0cy5ib2xkID0gYm9sZDtcbmNvbnN0IGl0YWxpYyA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGBfJHt0ZXh0fV9gO1xufTtcbmV4cG9ydHMuaXRhbGljID0gaXRhbGljO1xuY29uc3Qgc3RyaWtldGhyb3VnaCA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGB+fiR7dGV4dH1+fmA7XG59O1xuZXhwb3J0cy5zdHJpa2V0aHJvdWdoID0gc3RyaWtldGhyb3VnaDtcbmNvbnN0IHVuZGVybGluZSA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGA8dT4ke3RleHR9PC91PmA7XG59O1xuZXhwb3J0cy51bmRlcmxpbmUgPSB1bmRlcmxpbmU7XG5jb25zdCBsaW5rID0gKHRleHQsIGhyZWYpID0+IHtcbiAgICByZXR1cm4gYFske3RleHR9XSgke2hyZWZ9KWA7XG59O1xuZXhwb3J0cy5saW5rID0gbGluaztcbmNvbnN0IGNvZGVCbG9jayA9ICh0ZXh0LCBsYW5ndWFnZSkgPT4ge1xuICAgIGlmIChsYW5ndWFnZSA9PT0gXCJwbGFpbiB0ZXh0XCIpXG4gICAgICAgIGxhbmd1YWdlID0gXCJ0ZXh0XCI7XG4gICAgcmV0dXJuIGBcXGBcXGBcXGAke2xhbmd1YWdlfVxuJHt0ZXh0fVxuXFxgXFxgXFxgYDtcbn07XG5leHBvcnRzLmNvZGVCbG9jayA9IGNvZGVCbG9jaztcbmNvbnN0IGVxdWF0aW9uID0gKHRleHQpID0+IHtcbiAgICByZXR1cm4gYCQkXG4ke3RleHR9XG4kJGA7XG59O1xuZXhwb3J0cy5lcXVhdGlvbiA9IGVxdWF0aW9uO1xuY29uc3QgaGVhZGluZzEgPSAodGV4dCkgPT4ge1xuICAgIHJldHVybiBgIyAke3RleHR9YDtcbn07XG5leHBvcnRzLmhlYWRpbmcxID0gaGVhZGluZzE7XG5jb25zdCBoZWFkaW5nMiA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGAjIyAke3RleHR9YDtcbn07XG5leHBvcnRzLmhlYWRpbmcyID0gaGVhZGluZzI7XG5jb25zdCBoZWFkaW5nMyA9ICh0ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGAjIyMgJHt0ZXh0fWA7XG59O1xuZXhwb3J0cy5oZWFkaW5nMyA9IGhlYWRpbmczO1xuY29uc3QgcXVvdGUgPSAodGV4dCkgPT4ge1xuICAgIC8vIHRoZSByZXBsYWNlIGlzIGRvbmUgdG8gaGFuZGxlIG11bHRpcGxlIGxpbmVzXG4gICAgcmV0dXJuIGA+ICR7dGV4dC5yZXBsYWNlKC9cXG4vZywgXCIgIFxcbj4gXCIpfWA7XG59O1xuZXhwb3J0cy5xdW90ZSA9IHF1b3RlO1xuY29uc3QgY2FsbG91dCA9ICh0ZXh0LCBpY29uKSA9PiB7XG4gICAgbGV0IGVtb2ppO1xuICAgIGlmICgoaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpY29uLnR5cGUpID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgZW1vamkgPSBpY29uLmVtb2ppO1xuICAgIH1cbiAgICAvLyB0aGUgcmVwbGFjZSBpcyBkb25lIHRvIGhhbmRsZSBtdWx0aXBsZSBsaW5lc1xuICAgIHJldHVybiBgPiAke2Vtb2ppID8gZW1vamkgKyBcIiBcIiA6IFwiXCJ9JHt0ZXh0LnJlcGxhY2UoL1xcbi9nLCBcIiAgXFxuPiBcIil9YDtcbn07XG5leHBvcnRzLmNhbGxvdXQgPSBjYWxsb3V0O1xuY29uc3QgYnVsbGV0ID0gKHRleHQsIGNvdW50KSA9PiB7XG4gICAgbGV0IHJlbmRlclRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICByZXR1cm4gY291bnQgPyBgJHtjb3VudH0uICR7cmVuZGVyVGV4dH1gIDogYC0gJHtyZW5kZXJUZXh0fWA7XG59O1xuZXhwb3J0cy5idWxsZXQgPSBidWxsZXQ7XG5jb25zdCB0b2RvID0gKHRleHQsIGNoZWNrZWQpID0+IHtcbiAgICByZXR1cm4gY2hlY2tlZCA/IGAtIFt4XSAke3RleHR9YCA6IGAtIFsgXSAke3RleHR9YDtcbn07XG5leHBvcnRzLnRvZG8gPSB0b2RvO1xuY29uc3QgaW1hZ2UgPSBhc3luYyAoYWx0LCBocmVmLCBjb252ZXJ0VG9CYXNlNjQgPSBmYWxzZSkgPT4ge1xuICAgIC8vIEluIGNhc2UgdGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0byBjb252ZXJ0IHRoZSBpbWFnZXMgdG8gQmFzZTY0XG4gICAgLy8gb3IgdGhlIGltYWdlIGlzIGFscmVhZHkgYmFzZTY0XG4gICAgaWYgKCFjb252ZXJ0VG9CYXNlNjQgfHwgaHJlZi5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGJhc2U2NCBkYXRhLCBpLmUuIHRoZSBzdHJpbmcgYWZ0ZXIgJ2RhdGE6bWltZS90eXBlO2Jhc2U2NCwnXG4gICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBocmVmLnNwbGl0KFwiLFwiKS5wb3AoKTtcbiAgICAgICAgICAgIC8vIFRoaXMgb3ZlcnJpZGVzIGluY29ycmVjdCBkYXRhOiBzdHJpbmcgZm9ybWF0IHRvIHBuZ1xuICAgICAgICAgICAgLy8gc28gdGhhdCBicm93c2VycyBjYW4gY29ycmVjdGx5IHJlbmRlciB0aGUgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIGAhWyR7YWx0fV0oZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7YmFzZTY0fSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgIVske2FsdH1dKCR7aHJlZn0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgZG93bmxvYWQgdGhlIGltYWdlIGFuZCBjb252ZXJ0IGl0IHRvIGJhc2U2NFxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCAoMCwgbm9kZV9mZXRjaF8xLmRlZmF1bHQpKGhyZWYpO1xuICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmZyb20oYnVmKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgcmV0dXJuIGAhWyR7YWx0fV0oZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7YmFzZTY0fSlgO1xuICAgIH1cbn07XG5leHBvcnRzLmltYWdlID0gaW1hZ2U7XG5jb25zdCBhZGRUYWJTcGFjZSA9ICh0ZXh0LCBuID0gMCkgPT4ge1xuICAgIGNvbnN0IHRhYiA9IFwiXHRcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgY29uc3QgbXVsdGlMaW5lVGV4dCA9IHRleHQuc3BsaXQoLyg/Ol58XFxuKS8pLmpvaW4oYFxcbiR7dGFifWApO1xuICAgICAgICAgICAgdGV4dCA9IHRhYiArIG11bHRpTGluZVRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dCA9IHRhYiArIHRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufTtcbmV4cG9ydHMuYWRkVGFiU3BhY2UgPSBhZGRUYWJTcGFjZTtcbmNvbnN0IGRpdmlkZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFwiLS0tXCI7XG59O1xuZXhwb3J0cy5kaXZpZGVyID0gZGl2aWRlcjtcbmNvbnN0IHRvZ2dsZSA9IChzdW1tYXJ5LCBjaGlsZHJlbikgPT4ge1xuICAgIGlmICghc3VtbWFyeSlcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuIHx8IFwiXCI7XG4gICAgcmV0dXJuIGA8ZGV0YWlscz5cbjxzdW1tYXJ5PiR7c3VtbWFyeX08L3N1bW1hcnk+XG4ke2NoaWxkcmVuIHx8IFwiXCJ9XG48L2RldGFpbHM+XFxuXFxuYDtcbn07XG5leHBvcnRzLnRvZ2dsZSA9IHRvZ2dsZTtcbmNvbnN0IHRhYmxlID0gKGNlbGxzKSA9PiB7XG4gICAgcmV0dXJuICgwLCBtYXJrZG93bl90YWJsZV8xLmRlZmF1bHQpKGNlbGxzKTtcbn07XG5leHBvcnRzLnRhYmxlID0gdGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/utils/md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/notion-to-md/build/utils/notion.js":
/*!*********************************************************!*\
  !*** ./node_modules/notion-to-md/build/utils/notion.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.modifyNumberedListObject = exports.getBlockChildren = void 0;\nconst getBlockChildren = async (notionClient, block_id, totalPage) => {\n    let result = [];\n    let pageCount = 0;\n    let start_cursor = undefined;\n    do {\n        const response = (await notionClient.blocks.children.list({\n            start_cursor: start_cursor,\n            block_id: block_id,\n        }));\n        result.push(...response.results);\n        start_cursor = response === null || response === void 0 ? void 0 : response.next_cursor;\n        pageCount += 1;\n    } while (start_cursor != null &&\n        (totalPage == null || pageCount < totalPage));\n    (0, exports.modifyNumberedListObject)(result);\n    return result;\n};\nexports.getBlockChildren = getBlockChildren;\nconst modifyNumberedListObject = (blocks) => {\n    let numberedListIndex = 0;\n    for (const block of blocks) {\n        if (\"type\" in block && block.type === \"numbered_list_item\") {\n            // add numbers\n            // @ts-ignore\n            block.numbered_list_item.number = ++numberedListIndex;\n        }\n        else {\n            numberedListIndex = 0;\n        }\n    }\n};\nexports.modifyNumberedListObject = modifyNumberedListObject;\n//# sourceMappingURL=notion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL25vdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbm90aW9uLXRvLW1kL2J1aWxkL3V0aWxzL25vdGlvbi5qcz85MmRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb2RpZnlOdW1iZXJlZExpc3RPYmplY3QgPSBleHBvcnRzLmdldEJsb2NrQ2hpbGRyZW4gPSB2b2lkIDA7XG5jb25zdCBnZXRCbG9ja0NoaWxkcmVuID0gYXN5bmMgKG5vdGlvbkNsaWVudCwgYmxvY2tfaWQsIHRvdGFsUGFnZSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcGFnZUNvdW50ID0gMDtcbiAgICBsZXQgc3RhcnRfY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgbm90aW9uQ2xpZW50LmJsb2Nrcy5jaGlsZHJlbi5saXN0KHtcbiAgICAgICAgICAgIHN0YXJ0X2N1cnNvcjogc3RhcnRfY3Vyc29yLFxuICAgICAgICAgICAgYmxvY2tfaWQ6IGJsb2NrX2lkLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLnJlc3BvbnNlLnJlc3VsdHMpO1xuICAgICAgICBzdGFydF9jdXJzb3IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubmV4dF9jdXJzb3I7XG4gICAgICAgIHBhZ2VDb3VudCArPSAxO1xuICAgIH0gd2hpbGUgKHN0YXJ0X2N1cnNvciAhPSBudWxsICYmXG4gICAgICAgICh0b3RhbFBhZ2UgPT0gbnVsbCB8fCBwYWdlQ291bnQgPCB0b3RhbFBhZ2UpKTtcbiAgICAoMCwgZXhwb3J0cy5tb2RpZnlOdW1iZXJlZExpc3RPYmplY3QpKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmdldEJsb2NrQ2hpbGRyZW4gPSBnZXRCbG9ja0NoaWxkcmVuO1xuY29uc3QgbW9kaWZ5TnVtYmVyZWRMaXN0T2JqZWN0ID0gKGJsb2NrcykgPT4ge1xuICAgIGxldCBudW1iZXJlZExpc3RJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgaWYgKFwidHlwZVwiIGluIGJsb2NrICYmIGJsb2NrLnR5cGUgPT09IFwibnVtYmVyZWRfbGlzdF9pdGVtXCIpIHtcbiAgICAgICAgICAgIC8vIGFkZCBudW1iZXJzXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG9jay5udW1iZXJlZF9saXN0X2l0ZW0ubnVtYmVyID0gKytudW1iZXJlZExpc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlcmVkTGlzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLm1vZGlmeU51bWJlcmVkTGlzdE9iamVjdCA9IG1vZGlmeU51bWJlcmVkTGlzdE9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/notion-to-md/build/utils/notion.js\n");

/***/ })

};
;